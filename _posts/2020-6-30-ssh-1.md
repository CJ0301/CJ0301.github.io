---
layout: 		post
title: 			"SSH框架-1"
subtitle: 		'因为考试要考这破玩意，还是学一下吧'
author: 		"CJ"
header-img: 	"img/post-bg-android.jpg"
outer-img:		"post-bg-android.jpg"
header-mask: 	0.3
catalog: 		true
tags:
  - Java Web
---
## Struts2
#### 为啥要有Struts2
用原生代码实现Login功能
Servlet:   
```java
class LoginServlet{
	doPost(...){
		new LoginAction().excute();
	}
}
```
 
```java
class LoginAction{
	void execute(){
		
	}
}
```

Filter:  
```java
class LoginFilter{
	foFilter(...){
		new LoginAction.excute();
	}
}
```

```java
class LoginAction{
	void execute(){
		
	}
}
```

用Filter进行多任务处理
```java
class CoreFilter{
	doFilter(){
		map.put(".../login","xxx.xxx.LoginAction");
		map.put(.../register,"xxx.xxx.RegisterAction");
		map.put("success","/success.jsp");
		map.put("fail","/fail.jsp");

		//1.获取请求
		String path = request.getServletPath();
		//2.通过请求获取全限定类名
		String className = map.get(path);
		//3.使用反射机制根据全限定类名创建对象
		Object obj = Class.forName(className).newInstance();
		//4.调用方法	
		String flag = obj.getClass.getMethod("excute").invoke(obj,null);
		//5.从map获取要跳转的页面
		String page = map.get(flag);
		//6.完成跳转
		//请求转发
		request.getRequestDispatcher(page).forward(request,response)
		//重定向
		response.redirect("page");	
}
}
```

```java
class LoginAction{
	String excute(){
		...
		return "success";
	}
}
```

```java
class RegisterAction{
	String excute(){
		...
		return "fail";
	}
}
```

但是在上面用map无法实现热插拔，修改代码需要重新编译。这时候可以加一个文本文件对这些map进行管理。
```xml
<package>
	<action name="xxx" namespace="/xxx">
		<result name="success">/success.jsp</result>
	</action>
	<action name="xxx" namespace="/xxx">
		<result name="success">/fail.jsp</result>
	</action>
</package>
```

这时候就要在Filter中增加一个读取配置文件的过程。    
在struts2里，Filter和xml文件都有规范。

优点：  
1）非侵入式设计，Action是POJO类，不依赖于Servlet API和Struts API。
2）提供了拦截器，利用拦截器可进行AOP编程。  
3）提供类型转换器，可将特殊的请求参数转换成需要的类型。  
4）输入验证可对指定方法进行验证。  
5）提供全局范围、包范围和Action范围的国际化资源文件管理实现。  

#### 配置
这里的运行环境用的是Tomcat9.0 &nbsp; struts2.3  
用2.5的时候遇到点问题，好像只有2.3会有blank版本的项目，以后再研究2。5的问题吧。  
每个版本上xml的配置都不太一样，建议去下载的all包下的apps文件中找官方写的项目，2.3可以用blank的war包，改成zip后缀后直接解压，然后把web.xml中的内容复制出来就好，这一步不配好会404，而且还不报错。

首先是导入jar包，不用都导入，导入blank里的即可。

web.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

    <filter>
        <filter-name>struts2</filter-name>
        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>struts2</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
```

struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

</struts>
```

#### 写一个例子
第一步：写Action  
```java
public class LoginAction {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String execute(){
        System.out.println("name="+name);
        System.out.println("age="+age);
        return "success";
    }
}
```

第二步：在struts.xml中注册Action  
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <!--
        package：包，用于对Action进行封装
        name：包名，根元素下可以有多个包，彼此不能重名
        extends：继承，用于指定继承的包，相当于将继承包下的配置信息复制到当前包
        namespace：命名空间，用于规定Action的访问路径，必须“/”开头    -->
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="Login" class="actions.LoginAction">
            <result name="success">/welcome.jsp</result>
        </action>
    </package>
</struts>
```

如果struts-default爆红了，IDEA的解决方案是在Project Structure里选择Facets，右边有一个铅笔的图标，点一下添加依赖就好了。

index.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
    <form action="test/Login" method="post">
      姓名：<input type="text" name="name"/><br>
      年龄：<input type="text" name="age"/><br>
      <input type="submit" value="登陆"/>
    </form>
  </body>
</html>
```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
    name=${name}<br>
    age=${age}
  </body>
</html>
```

执行流程：  
1.先由index.jsp中的表单提交请求。  
2.再通过表单的action属性找到package的namespace，查找对应包下的action，映射到想应的类。  
3.再由相应的Action类中的execute方法处理，返回字符串结果，同时转发到相应的页面。  

## 核心配置文件

配置文件：  
struts-default.xml  
default.properties  
struts.properties  
web.xml

这些配置文件与struts.xml一样，需要在src下新建才能重写属性。  

例如：  
struts.properties  
```xml
struts.action.extension=php,html
```

那么表单里的action需要加.php或.html。  
```html
<form action="test/Login.php" method="post">
	姓名：<input type="text" name="name"/><br>
	年龄：<input type="text" name="age"/><br>
	<input type="submit" value="登陆"/>
</form>
```

#### Action
如果注册action时没设置class，则会调用默认ActionSupport类的execute方法，返回success。  
注册的action调用非execute方法时需要加method属性将方法名作为参数传入。  
success可以省略不写。  
struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <!--
        package：包，用于对Action进行封装
        name：包名，根元素下可以有多个包，彼此不能重名
        extends：继承，用于指定继承的包，相当于将继承包下的配置信息复制到当前包
        namespace：命名空间，用于规定Action的访问路径，必须“/”开头    -->
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="Method1" class="actions.LoginAction" method="method1">
            <result name="success">/welcome.jsp</result>
        </action>
        <!--success可省略-->
        <action name="Method2" class="actions.LoginAction" method="method2">
            <result>/welcome.jsp</result>
        </action>
    </package>
</struts>
```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
  <a href="test/Method1">Method1</a>
  <a href="test/Method2">Method2</a>
  </body>
</html>
```

#### Result
type属性
result的type属性默认是请求转发。如果重定向要获取参数，得这么改：  

struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="Login" class="actions.LoginAction">
            <result type="redirect">
                <param name="location">/welcome.jsp</param>
                <param name="name">${name}</param>
                <param name="age">${age}</param>
            </result>
        </action>
    </package>
</struts>
```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
    param.name = ${param.name}<br>
    param.age = ${param.age}<br>
  </body>
</html>
```

官方的建议是转发到Action中： 
struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="Login" class="actions.LoginAction">
            <result type="redirectAction">
                <param name="actionName">second</param>
                <param name="name">${name}</param>
                <param name="age">${age}</param>
            </result>
        </action>
        <action name="second" class="actions.SecondAction">
            <result>/welcome.jsp</result>
        </action>
    </package>
</struts>
```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
    name=${name}<br>
    age=${age}<br>
    requestScope.name=${requestScope.name}<br>
    requestScope.age=${requestScope.age}<br>
    param.name = ${param.name}<br>
    param.age = ${param.age}<br>
  </body>
</html>
```

这里SecondAction和之前的Action一样。

请求转发转发到action：  
struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="Login" class="actions.LoginAction">
            <result type="chain">second</result>
        </action>
        <action name="second" class="actions.SecondAction">
            <result>/welcome.jsp</result>
        </action>
    </package>
</struts>
```

SecondAction.java
```java
public class SecondAction {

    public String execute(){
        return "success";
    }
}
```

jsp页面和上面的一样。

#### 全局视图与多配置文件
包范围的全局视图    
在package中使用<global-results>标签，当action找不到结果视图时会在全局找。

应用范围的全局视图  
把package的extends属性定义成一个公共的包，公共包可以去掉namespace，同时定义abstract，属性为true。

多配置文件  
在struts用include标签的file属性指定子文件即可。
也可以直接用<include file="struts-*.xml" />等策略简化写法。

## struts核心
#### 获取ServletAPI
ServletAction.java
```java
public class ServletAction {

    public String execute(){
        //下面方法获取到的仅仅是这些ServletAPI的域空间
        //而不是真正的ServletAPI

        //向request域空间中存入数据
        ActionContext.getContext().put("req","req_value");
        //向session域空间中存入数据
        ActionContext.getContext().getSession().put("ses","ses_value");
        //向Application(ServletContext)域空间中存入数据
        ActionContext.getContext().getApplication().put("app","app_value");

        //真正的ServletAPI
        HttpServletRequest request = ServletActionContext.getRequest();
        request.setAttribute("sReq","sReq_value");
        request.getSession().setAttribute("sSes","sSes_value");
        ServletActionContext.getServletContext().setAttribute("sApp","sApp_value");
        return "success";
    }
}
```

struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <package name="xxx" namespace="/test" extends="struts-default">
        <action name="servlet" class="actions.ServletAction">
            <result>/welcome.jsp</result>
        </action>
    </package>
</struts>
```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title></title>
  </head>
  <body>
    req=${requestScope.req}<br>
    ses=${sessionScope.ses}<br>
    app=${applicationScope.app}<br>
    sReq=${requestScope.sReq}<br>
    sSes=${sessionScope.sSes}<br>
    sApp=${applicationScope.sApp}<br>
  </body>
</html>
```

也可以用RequestAware，SessionAware，ApplicationAware三个接口，一般这么用。

#### OGNL与值栈
OGNL的特点：  
- 支持对象方法调用，如xxx.sayHello()  
- 支持静态方法和常量访问，表达式格式为：  
@[全限定性类名]@[方法名|常量名]
静态方法访问需要在struts.xml中设置常量struts.ognl.allowStaticMethodAccess  
- 可以操作集合对象
- 可以直接创建对象

首先设置taglib和前缀    
index.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
  <head>
    <title></title>
  </head>
  <body>
    PI = <s:property value="@java.lang.Math@PI"/><br>
    random = <s:property value="@java.lang.Math@random() * 100"/>
  </body>
</html>
```

引用方法需要修改配置文件
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <constant name="struts.ognl.allowStaticMethodAccess" value="true" />
</struts>
```

值栈的获取

someAction.java  
```java
public class someAction {

    public String execute(){

        //从request中获取ValueStack对象
        String key = ServletActionContext.STRUTS_VALUESTACK_KEY;
        HttpServletRequest request = ServletActionContext.getRequest();
        ValueStack vs = (ValueStack)request.getAttribute(key);

        Map<String,Object> context = vs.getContext();
        context.put("city","Beijing");
        //ActionContext是值栈context的别名，操作的是同一个对象
        ActionContext.getContext().put("city","Shanghai");

        //从ActionContext获取ValueStack对象
        ValueStack vs2 = ActionContext.getContext().getValueStack();

        System.out.println(vs+"");
        System.out.println(vs2+"");
        return "success";
    }
}
```

index.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
  <head>
    <title></title>
  </head>
  <body>
    city=<s:property value="#city" />
  </body>
</html>
```

值栈操作    
向root中显式的放入数据  
Student.java
```java
public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "name="+name+"  age="+age;
    }
}
```

someAction.java
```
public class someAction {

    public String execute(){

        String key = ServletActionContext.STRUTS_VALUESTACK_KEY;
        HttpServletRequest request = ServletActionContext.getRequest();
        ValueStack vs = (ValueStack)request.getAttribute(key);

        //向root属性中直接放入无名对象
        Student student = new Student("张三",23);
        vs.getRoot().push(student);

        //向值栈中直接放入无名对象，但实际也是放入到了其root属性中
        vs.push(new Student("李四",22));

        //向root属性中直接放入有名对象
        Map<String,Student> map = new HashMap<String,Student>();
        map.put("student3",new Student("王五",66));
        vs.push(map);

        //向root属性中直接放入有名对象，本质上与上面的一样
        vs.set("student4",new Student("赵六",44));

        //将root作为ArrayList传入数据,与栈不同，这是从底部加
        vs.getRoot().add(new Student("田七",27));
        System.out.println(vs.getRoot().get(6).toString());

        return "success";
    }
}

```

index.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
  <head>
    <title></title>
  </head>
  <body>
  <s:debug />
    name = <s:property value="name"/><br>
    age = <s:property value="age"/><br>
    student3.name = <s:property value="student3.name"/><br>
    student3.age = <s:property value="student3.age"/><br>
    student4.name = <s:property value="student4.name"/><br>
    student4.age = <s:property value="student4.age"/><br>
  </body>
</html>
```

向root隐式的放入数据    
LoginAction.java
```java
public class LoginAction {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String execute(){
        System.out.println("name="+name);
        System.out.println("age="+age);
        return "success";
    }
}

```

welcome.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <s:debug/>
    name = <s:property value="name"/><br>
    age = <s:property value="age" />
</body>
</html>
```

index.jsp和之前的表单一样。

向context显式放入数据  
someAction.java
```java
public class someAction {

    public String execute(){
        //向request域空间中存入数据
        ActionContext.getContext().put("some","req_value");
        //向session域空间中存入数据
        ActionContext.getContext().getSession().put("ses","ses_value");
        //向Application(ServletContext)域空间中存入数据
        ActionContext.getContext().getApplication().put("app","app_value");

        return "success";
    }
}
```

index.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
  <head>
    <title></title>
  </head>
  <body>
    <s:debug/>
    #some = <s:property value="#some"/><br>
    #session.ses = <s:property value="#session.ses"/><br>
    #application.app = <s:property value="#application.app"/>
  </body>
</html>
```

向context隐式放入数据
登陆的Action和jsp和之前一样
welcome.jsp
```html
<!--#parameters.name底层执行的是request.getParameter("name")-->
#parameters.name = <s:property value="#parameters.name"/><br>
#parameters.age = <s:property value="#parameters.age"/><br>
#action.name = <s:property value="#action.name"/><br>
#action.age = <s:property value="#action.age"/><br>
```

parameters存放的是对象字符串数组。  
action存放的是action对象。

root数据的加载顺序，当root中没数据时，代码会从context中找数据。  
存入数据  
```java
//向request域空间中存入数据
ActionContext.getContext()
	.put("some","req_value");
```

获取数据
```html
some = <s:property value="some"/><br>
#some = <s:property value="#some"/><br>
```


request加载顺序  
存入数据
```java
//向request域空间中存入数据
ActionContext.getContext().put("some","req_value");
ActionContext.getContext().getValueStack().set("some","root_value");
```

获取数据
```html
some = <s:property value="some"/><br>
#some = <s:property value="#some"/><br>
<!--#request.some底层执行的是request.getAttribute("some")
#request.some被struts2包装后的查找顺序是：
1）request域空间
2）root
3）context-->
#request.some = <s:property value="#request.some" />
```

#### 集合操作
index.jsp
```html
--------------list--------------<br>
<s:set name="mList" value="{'zc','ls','ww'}"/>
<!--iterator标签默认会将当前迭代对象放入值栈栈顶-->
<s:iterator value="#mList">
	<s:property /><br><!--property标签默认会输出值栈栈顶元素-->
</s:iterator>
--------------map--------------<br>
<s:set name="mMap" value="#{'mobile':'iPhone','qq':'784864'}"/>
<s:iterator value="#mMap">
	<s:property /><br><!--property标签默认会输出值栈栈顶元素-->
</s:iterator>
<s:iterator  value="#mMap" var="entry">
	<s:property value="entry"/><br>
</s:iterator>
<s:iterator  value="#mMap">
	<s:property value="key"/> = <s:property value="value"/><br>
</s:iterator>

--------------in not in--------------<br>
<s:property value="'zs' in #mList"/><br>
<s:property value="'zs' not in #myList"/><br>


--------------创建Bean--------------<br>
<s:bean name="actions.Student" id="student3">
	<s:param name="name" value="'问问3'"/>
	<s:param name="age" value="20"/>
</s:bean>

<s:property value="#student3"/><br>

<s:bean name="actions.Student" id="student4">
	<s:param name="name" value="'问问4'"/>
	<s:param name="age" value="24"/>
</s:bean>

<s:bean name="actions.Student" id="student5">
	<s:param name="name" value="'问问5'"/>
	<s:param name="age" value="23"/>
</s:bean>

--------------集合投影：将三个Student对象的name属性再组成一个List--------------<br>
<s:set name="students" value="{#student3,#student4,#student5}"/>
<s:set name="studentNames" value="#students.{name}"/>

<s:iterator value="#studentNames">
	<s:property /><br>
</s:iterator>

--------------集合查询：将三个Student对象的name属性再组成一个List--------------<br>
<s:iterator value="#students.{?#this.age>21}">
	<s:property /><br>
</s:iterator>

查找第一个符合条件的<br>
<s:iterator value="#students.{^#this.age>21}">
	<s:property /><br>
</s:iterator>

查找最后一个符合条件的<br>
<s:iterator value="#students.{$#this.age>21}">
	<s:property /><br>
</s:iterator>
```

#### 动态调用方法

someAction.java
```java
public class someAction {

    public String doFirst(){
        System.out.println("执行方法doFirst()");
        return "success";
    }

    public String doSecond(){
        System.out.println("执行方法doSecond()");
        return "success";
    }
}
```

第一种方法，注册两个action  

struts.xml
```xml
<action name="first" class="actions.someAction" method="doFirst">
	<result>index.jsp</result>
</action>
<action name="second" class="actions.someAction" method="doSecond">
	<result>index.jsp</result>
</action>
```

第二种方法，修改常量DynamicMethodInvocation，路径中加入!doFirst即可访问相应的doFirst方法

struts.xml
```xml
<struts>
    <constant name="struts.enable.DynamicMethodInvocation" value="true" />
    <package name="xxx" namespace="/" extends="struts-default">
        <action name="some" class="actions.someAction">
            <result>index.jsp</result>
        </action>
    </package>
</struts>
```

前两个都不建议使用，建议使用第三种
在name后加上通配符，只要获取该通配符数据访问相应的方法即可
```xml
<struts>
    <package name="xxx" namespace="/" extends="struts-default">
        <action name="some_*" class="actions.someAction" method="{1}">
            <result>index.jsp</result>
        </action>
    </package>
</struts>
```

#### 接收请求参数
属性驱动  
将请求参数作为action的属性，只针对表单属性比较少的情况，一般不用。

域驱动方式  
Student.java
```java
public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        System.out.println("getName() name = "+name);
        return name;
    }

    public void setName(String name) {
        System.out.println("setName() name = "+name);
        this.name = name;
    }

    public int getAge() {
        System.out.println("getAge() age = "+age);
        return age;
    }

    public void setAge(int age) {
        System.out.println("setAge() age = "+age);
        this.age = age;
    }

    @Override
    public String toString() {
        return "name="+name+"  age="+age;
    }
}

```

someAction.java
```java
public class someAction {
    private Student student;//域属性，对象属性

    public Student getStudent() {
        System.out.println("getStudent() student = "+student);
        return student;
    }

    public void setStudent(Student student) {
        System.out.println("setStudent() student = "+student);
        this.student = student;
    }

    public String execute(){

        return "success";
    }
}

```

index.jsp
```html
<form action="some" method="post">
	姓名：<input type="text" name="student.name"/><br>
	年龄：<input type="text" name="student.age"/><br>
	<input type="submit" value="登陆"/>
</form>
```

welcome.jsp
```html
name = <s:property value="student.name"/><br>
age = <s:property value="student.age"/><br>
```

工作原理：   
表单的请求发出后，表单会根据student先找相应的域对象，创建该对象并使其对象初始化，然后再往里面放数据。

模型驱动  
someAction.java
```java
public class someAction implements ModelDriven<Student> {
    private Student student;//域属性，对象属性

    public String execute(){

        return "success";
    }

    @Override
    public Student getModel() {
        if(student == null){
            student = new Student();
        }
        return student;
    }
}
```

index.jsp
```html
<form action="some" method="post">
	姓名：<input type="text" name="name"/><br>
	年龄：<input type="text" name="age"/><br>
	<input type="submit" value="登陆"/>
</form>
```

welcome.jsp
```html
name = <s:property value="name"/><br>
age = <s:property value="age"/><br>
```

集合数据的接收  
someAction.java
```java
public class someAction{
    private List<Student> students;//域属性，对象属性

    public List<Student> getStudents() {
        return students;
    }

    public void setStudents(List<Student> students) {
        this.students = students;
    }

    public String execute(){

        return "success";
    }

}
```

index.jsp
```html
<form action="some" method="post">
	姓名1：<input type="text" name="students[0].name"/><br>
	年龄1：<input type="text" name="students[0].age"/><br>
	姓名2：<input type="text" name="students[1].name"/><br>
	年龄2：<input type="text" name="students[1].age"/><br>
	<input type="submit" value="登陆"/>
</form>
```

welcome.jsp
```html
name1 = <s:property value="students[0].name"/><br>
age1 = <s:property value="students[0].age"/><br>
name2 = <s:property value="students[1].name"/><br>
age2 = <s:property value="students[1].age"/><br>
```

#### 类型转换
常见类型均可由String自动转换  
- int和Integer    
- long和Long  
- float和Float  
- double和Double  
- char和Character  
- boolean和Boolean  
- Date：可以接收yyyy-MM-dd或yyyy-MM-dd HH:mm:ss格式字符串  
- 数组：可以将多个同名参数，存放到数组  
- 集合：可以将数据保存到List、Map

如之前的表单提交，都有自动转换。

但是之前的是非强制转换，如果年龄的input输入了23a也会显示，但是不是放在Action里了，这时候需要在Action处继承ActionSupport

someAction.java
```
public class someAction extends ActionSupport {
    private int age;
    private Date birthday;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String execute(){
        System.out.println("age"+age);
        System.out.println("birthday"+birthday);
        return "success";
    }
}
```

自定义数据转换器
```java
public class MyDataConverter extends DefaultTypeConverter {
    /**
     * value:将要被转换的值
     * toType:要转换成为的目标类型
     * 页面->服务端：String->Date
     * 服务端->页面：Date->String
     * */
    @Override
    public Object convertValue(Map context, Object value, Class toType) {
        System.out.println("执行");
        SimpleDateFormat sdf = null;
        try{
            if(toType == Date.class){//页面到服务端
                String dateStr = ((String[])value)[0];
                System.out.println("date  "+dateStr);
                //获取日期格式类型
                sdf = getSimpleDateFormat(dateStr);
                ActionContext.getContext().getSession().put("sdf",sdf);
                return sdf.parse(dateStr);
            }else if(toType == String.class){//服务端到页面
                Date date = (Date)value;
                sdf = (SimpleDateFormat)ActionContext.getContext().getSession().get("sdf");
                return sdf.format(date);
            }

        } catch (ParseException e) {
            e.printStackTrace();
        }
        return super.convertValue(context, value, toType);
    }

    private SimpleDateFormat getSimpleDateFormat(String source){
        SimpleDateFormat sdf = null;
        if(Pattern.matches("^\\d{4}-\\d{2}-\\d{2}$",source)){
            sdf = new SimpleDateFormat("yyyy-MM-dd");
        }else if(Pattern.matches("^\\d{4}\\d{2}\\d{2}$",source)){
            sdf = new SimpleDateFormat("yyyyMMdd");
        }else if(Pattern.matches("^\\d{4}/\\d{2}/\\d{2}$",source)){
            sdf = new SimpleDateFormat("yyyy/MM/dd");
        }else{
            throw new TypeConversionException();
        }
        return sdf;
    }
}
```

需要加配置文件，命名为action类名+-conversion.properties  
someAction-conversion.properties
```
birthday=actions.MyDataConverter
```

struts表单  
index.jsp
```html
<s:form action="some" method="POST">
	<s:textfield name="age" label="年龄"/>
	<s:textfield name="birthday" label="生日"/>
	<s:submit value="登陆"/>
</s:form>
```

修改输入错误提示语句需要在配置文件中配置，命名格式为action类名+.properties  
```
invalid.fieldvalue.age = \u65E0\u6CD5\u8F6C\u6362\u4E3A\u6570\u5B57
```

#### 数据验证
代码解决方案  
someAction.java
```java
public class someAction extends ActionSupport {
    private String name;
    private String mobile;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }

    public String execute(){
        return "success";
    }

    public String doFirst(){
        return "success";
    }

    public void validateDoFirst() {
        if(mobile == null || "".equals(mobile)){
            this.addFieldError("mobile","手机号不能为空(doFirst)");
        }else if(!Pattern.matches("^1[345678]\\d{9}$",mobile)){
            this.addFieldError("mobile","手机号不正确(doFirst)");
        }
    }

    @Override
    public void validate() {
        if(name == null || "".equals(name)){
            //如果filedErrors.size()>0,则自动跳转到input视图
            this.addFieldError("name","用户名不能为空");
        }
        if(mobile == null || "".equals(mobile)){
            this.addFieldError("mobile","手机号不能为空");
        }else if(!Pattern.matches("^1[345678]\\d{9}$",mobile)){
            this.addFieldError("mobile","手机号不正确");
        }
    }
}
```

这里写了两种，一种是直接覆写validate方法，针对所有方法的判断，还有一个是针对方法的判断，方法名需变成validate+方法名。

index.jsp
```html
<!--也可以在正常的form加s:fielderror-->
<s:form action="some_doFirst" method="POST">
	<s:textfield name="name" label="名字"/>
	<s:textfield name="mobile" label="手机号"/>
	<s:submit value="登陆"/>
</s:form>
```

xml文件配置验证  
开头不会打在jar包中找xwork-core的包，打开xwork-validator最新版本复制开头即可。 
命名方式是action类名+-validation.xml，限定方法要在类名后加_方法名。  
someAction-validation.xml 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator 1.0.3//EN"
        "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validators>
    <field name="name">
        <field-validator type="requiredstring">
            <param name="trim">true</param>
            <message>缺少用户名</message>
        </field-validator>
    </field>
    <field name="mobile">
        <field-validator type="requiredstring">
            <message>手机号不能为空</message>
        </field-validator>
        <field-validator type="regex">
            <param name="regexExpression"><![CDATA[^1[345678]\d{9}$]]></param>
            <message>手机号格式不正确</message>
        </field-validator>
    </field>
</validators>
```

常用验证器  
required 非空验证器  
```
<field-validator type="required">
	<message>缺少用户名</message>
</field-validator>
``` 

requiredstring 非空字符串验证器 
```
<field-validator type="requiredstring">
	<param name="trim">true</param>
	<message>缺少用户名</message>
</field-validator>
``` 
fieldexpression 字段表达式关系判断(假设pwd和repwd是表单中的两个元素的name属性值)  
```
<field-validator type="fieldexpression">
	<param name="expression">pwd==repwd</param>
	<message>确认密码与密码不一致</message>
</field-validator>
``` 

stringlength 字符串长度验证器  
```
<field-validator type="stringlength">
	<param name="min">1</param>
	<param name="max">20</param>
	<message>长度要在1-20之间</message>
</field-validator>
``` 

int 整数范围校验器
```
<field-validator type="int">
	<param name="min">1</param>
	<param name="max">20</param>
	<message>数字要在1-20之间</message>
</field-validator>
``` 

email 邮箱地址校验器
```
<field-validator type="email">
	<message>邮箱地址无效</message>
</field-validator>
``` 

regex 正则校验器
```
<field-validator type="regex">
	<param name="regexExpression"><![CDATA[^1[345678]\d{9}$]]></param>
	<message>手机号格式不正确</message>
</field-validator>
``` 
注：<![CDATA[^1[345678]\d{9}$]]>称为cData区域，用于存放特殊表达式。

Action类的执行顺序    
1）类型转换  
类型转换失败是在Action调用相应属性的set方法之前发生的，转换失败不影响程序运行。  
2）set方法    
无论转换是否成功，都会执行该属性的set方法。只不过转换失败会为null。  
3）数据验证    
验证器对set方法设置的属性值进行验证，若验证失败，则将失败信息写入fieldErrors集合。当所有验证完毕，若存在异常信息，workFlow拦截器会返回一个"input"字符串，使请求转发到input视图。请求将不从Action走，无法执行方法。    
如果在类型转换就发生了异常，不仅会将异常写入fieldErrors集合，还会继承执行该属性的set方法，将属性赋值null，同时验证失败的信息也会写入到fieldErrors集合中。  
4）Action方法    
经过上面的执行，如果无异常，系统将自动执行Action方法。

#### 拦截器
SystemAction.java
```java
public class SystemAction {
    public String doFirst(){
        System.out.println("doFirst 已进入系统");
        return "success";
    }

    public String doSecond(){
        System.out.println("doSecond 已进入系统");
        return "success";
    }
}
```

MyInterceptor.java
```java
public class MyInterceptor extends MethodFilterInterceptor {
    @Override
    protected String doIntercept(ActionInvocation actionInvocation) throws Exception {
        System.out.println("MyInterceptor拦截器");
        return actionInvocation.invoke();
    }
}
```

PermissionInterceptor.java
```java
public class PermissionInterceptor extends AbstractInterceptor{
    @Override
    public String intercept(ActionInvocation actionInvocation) throws Exception {
        System.out.println("PermissionInterceptor拦截器");
        String name = (String)ActionContext.getContext().getSession().get("name");
        if(name!=null){
            //调用Action方法
            return actionInvocation.invoke();
        }
        return "fail";
    }
}
```

struts.xml
```xml
<package name="xxx" namespace="/" extends="struts-default">
        <interceptors>
            <interceptor name="permissionInterceptor" class="PermissionInterceptor">

            </interceptor>
            <interceptor name="MyInterceptor" class="MyInterceptor">
                <param name="includeMethods">doFirst</param>
            </interceptor>
            <!--执行与注册顺序一致-->
            <interceptor-stack name="stack">
                <interceptor-ref name="permissionInterceptor" />
                <interceptor-ref name="defaultStack"></interceptor-ref>
                <interceptor-ref name="MyInterceptor"></interceptor-ref>
            </interceptor-stack>
        </interceptors>

        <!--第三种 全局配置默认栈-->
        <default-interceptor-ref name="stack" />

        <action name="system_*" class="actions.SystemAction" method="{1}">
            <result>/welcome.jsp</result>
            <result name="fail">fail.jsp</result>
                <!--第一种 一个一个配置-->
<!--            <interceptor-ref name="permissionInterceptor" />-->
<!--            <interceptor-ref name="defaultStack" />-->
                <!--第二种 通过栈配置-->
<!--                <interceptor-ref name="stack" />-->
        </action>
</package>
```

login.jsp
```html
 <% session.setAttribute("name","CJ"); %>
```

logout.jsp
```html
 <% session.removeAttribute("name"); %>
```

#### 文件上传
浏览器上传文件会通过fileUpload拦截器自动完成上传，将文件放在临时目录。
UploadAction.java
```java
public class UploadAction {
    private File[] img;
    private String[] imgFileName; //必须是FileName结尾

    public File[] getImg() {
        return img;
    }

    public void setImg(File[] img) {
        this.img = img;
    }

    public String[] getImgFileName() {
        return imgFileName;
    }

    public void setImgFileName(String[] imgFileName) {
        this.imgFileName = imgFileName;
    }

    public String execute(){

        //没有上传不会进行创建
        if(img!=null){
            for(int i=0;i<img.length;i++){
                try {
//          String path = "d:/images";
                    String path = ServletActionContext.getServletContext().getRealPath("/images");
                    System.out.println(path);
                    File destFile = new File(path,imgFileName[i]);
                    FileUtils.copyFile(img[i],destFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return "success";
        }
        return "false";
    }

}
```

struts.xml
```xml
<!--单次发送总和-->
	<constant name="struts.multipart.maxSize" value="20971520"></constant>
    <package name="xxx" namespace="/" extends="struts-default">
        
        <action name="upload" class="actions.UploadAction">
            <result>welcome.jsp</result>
            <result name="false">fail.jsp</result>
            <interceptor-ref name="defaultStack">
                <param name="fileUpload.allowedExtensions">.jpg,.png</param>
            </interceptor-ref>
        </action>
    </package>
```

index.jsp
```html
<form action="upload" method="post" enctype="multipart/form-data">
        文件1：<input type="file" name="img" /><br>
        文件2：<input type="file" name="img" /><br>
        文件3：<input type="file" name="img" /><br>
        <input type="submit" value="登陆"/>
    </form>
```
#### 文件下载
DownloadAction.java
```java
public class DownloadAction {
    private InputStream is;//如果使用默认的inputStream可不配置
    private String fileName;

    public InputStream getIs() {
        return is;
    }

    public void setIs(InputStream is) {
        this.is = is;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public String execute(){
        try {
            fileName = "3.png";
			//路径在Web目录下
            is = ServletActionContext.getServletContext().getResourceAsStream("/images/"+fileName);
            fileName = "美景.png";
            //文件名中文乱码问题
            byte[] bytes = fileName.getBytes("utf-8");
            fileName = new String(bytes,"iso-8859-1");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return "success";
    }
}

```

struts.xml
```xml
<action name="download" class="actions.DownloadAction">
            <result type="stream">
                <param name="contentDisposition">attachment;filename=${fileName}</param>
                <param name="inputName">is</param>
            </result>
        </action>
```

index.jsp
```html
<a href="download">下载</a>
```

#### 表单重复提交
原理就是由表单页面的token标签生成与服务器一致的识别码，刷新后服务器识别码改变，就会由拦截器返回invalid.token。

LoginAction没啥特别的，带两个属性即可

struts.xml
```xml
<action name="login" class="actions.LoginAction">
            <result>welcome.jsp</result>
            <result name="invalid.token">message.jsp</result>
            <interceptor-ref name="token"></interceptor-ref>
            <interceptor-ref name="defaultStack"></interceptor-ref>
        </action>
```

index.jsp
```html
<form action="login" method="post">
      <s:token/>
      姓名：<input type="text" name="name" /><br>
      年龄：<input type="text" name="age" /><br>
      <input type="submit" value="登陆">
    </form>
```

## struts2注解式开发
使用注解徐将struts2-convention-plugin-2.3.37.jar包引入。

引入目的：替换xml文件

#### 注解详解  
@ParentPackage  
用于指定当前包所要继承的父包。相当于package标签中的extends属性。  

@Namespace  
用于指定该 Action 所在的命名空间。相当于 struts.xml 中<package/>的 namespace 属性。
不过，需要注意的是，即使不同的 Action 类的@Namespace 的值相同，也不能等同于说这两
个 Action 类中的@Action 处于同一个 Package 下。注解中没有配置文件中<package/>这个包
的概念。

@Results  
用于定义 Action 类范围的全局视图。若该 Action 类中定义有多个 Action 方法，则它们
可使用该全局视图。  
该全局视图相当于 struts.xml 中的<global-results/>标签，但不同于该标签。<global-results/>
标签定义的为包范围的全局视图，其可以应用到本<package/>中的任意 Action 类定义的
<action/>的视图中。而 Action 类范围的全局视图，只能应用到当前 Action 类的所有 Action
方法所定义的@Action 的视图中。即使两个 Action 类的@Namespace 值相同，也不能共享同
一个@Results。

@Result    
用于定义具体的视图，相当于 struts.xml 中的<result/>标签。查看源码可知，其可作为
其它注解的属性值。它有四个属性，且都有默认值。

@Action  
用于注解一个 Action。可以注解在类、接口与方法上。相当于 struts.xml 中的<action/>
标签。注意，<action/>并不是定义一个 Action 类，而是定义一个 Action 请求响应，即 Action
类+method。而@Action 也是在定义一个 Actiony 请求响应。所以，@Action 是可以定义在方
法上的。  
@Action 中的参数比较多，常用的有三个：  
value：指定该 Action 要响应的请求。相当于<action/>标签的 name 属性。  
results：该 Action 的跳转视图。注意，在 Action 类上还定义的有全局视图。  
interceptorRefs：该 Action 执行之前要经过的所有拦截器。相当于<action/>标签的
<interceptor-ref/>标签。

@InterceptorRef  
用于声明所引用的拦截器。相当于 struts.xml 中<interceptors/>标签的<interceptor/>子标
签。

@InterceptorRefs  
只能标注在类或接口上，用于定义该类使用的默认拦截器。该注解与@InterceptorRef
相结合，相当于 struts.xml 中<package/>的默认拦截器子标签<default-interceptor-ref/>。

#### 示例
重定向  
LoginAction.java
```java
//只有一个属性可省略
@Namespace("/")
@ParentPackage("struts-default")
public class LoginAction extends ActionSupport {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Action(value = "login",results = {@Result(type = "redirectAction",location = "second",params = {"name","%{name}","age","%{age}"})})
    public String execute(){

        return "success";
    }
}
```

SecondAction.java
```
@Namespace(value = "/")
@ParentPackage(value = "struts-default")
public class SecondAction extends ActionSupport {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Action(value = "second",results = {@Result(name = "success",type = "dispatcher",location = "/welcome.jsp")})
    public String execute(){

        return "success";
    }
}

```

index.jsp
```html
<form action="first" method="post">
    姓名：<input type="text" name="name"/><br>
    年龄：<input type="text" name="age"/><br>
    <input type="submit" value="登陆"/>
</form>
```

welcome.jsp
```html
param.name = ${param.name}<br>
param.age = ${param.age}<br>
```

全局视图  
CheckAction.java
```java
@Namespace(value = "/")
@ParentPackage(value = "struts-default")
@Results({@Result(name="ar",location = "/pageA.jsp"),@Result(name="br",location = "/pageB.jsp")})//全局视图
public class CheckAction extends ActionSupport {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Action(value = "first",results = {@Result(name="welcome",location = "/welcome.jsp")})
    public String doFirst(){
        if(age<15){
            return "ar";
        }
        return "br";
    }

}
```

拦截器    
定义拦截器需要设置一个抽象父包
struts.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
        "http://struts.apache.org/dtds/struts-2.3.dtd">

<struts>
    <package name="basePackage" namespace="/" extends="struts-default" abstract="true">
        <interceptors>
            <interceptor name="permissionInterceptor" class="PermissionInterceptor" />

            <!--执行与注册顺序一致-->
            <interceptor-stack name="stack">
                <interceptor-ref name="permissionInterceptor" />
                <interceptor-ref name="defaultStack" />
            </interceptor-stack>
        </interceptors>

    </package>
</struts>
```

SystemAction.java
```java
@Namespace(value = "/")
@ParentPackage(value = "basePackage")
public class SystemAction {

    @Action(value = "system",results = {@Result(location = "/welcome.jsp"),@Result(name = "fail",location = "/pageA.jsp")}
    ,interceptorRefs = @InterceptorRef(value = "stack"))
    public String execute(){
        System.out.println("进入系统");
        return "success";
    }
}
```